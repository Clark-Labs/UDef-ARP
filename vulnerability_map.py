import os
import numpy as np
from osgeo import gdal
from PyQt5.QtCore import QObject, pyqtSignal

class VulnerabilityMap(QObject):
    progress_updated = pyqtSignal(int)
    def __init__(self):
        super(VulnerabilityMap, self).__init__()
        self.data_folder = None
        self.initial_directory = None

    def set_working_directory(self, directory):
        '''
        Set up the working directory
        :param directory: your local directory with all dat files
        '''
        self.progress_updated.emit(0)
        # self.initial_directory = os.getcwd()
        self.data_folder = directory
        os.chdir(self.data_folder)

    def image_to_array(self,image):
        # Set up a GDAL dataset
        in_ds = gdal.Open(image)
        # Set up a GDAL band
        in_band = in_ds.GetRasterBand(1)
        # Create Numpy Array1
        arr = in_band.ReadAsArray()
        return arr

    def geometric_classification(self, in_fn, NRT, n_classes):
        '''
        geometric classification
        :param in_fn: map of distance from the forest eddge
        :param NRT:Negligible Risk Threshold
        :param n_classes:number of classes
        :return: mask_arr: result array with mask larger than NRT
        '''
        # Convert in_fn to NumPy array
        # Set up a GDAL dataset
        in_ds = gdal.Open(in_fn)
        # Set up a GDAL band
        in_band = in_ds.GetRasterBand(1)
        # Create Numpy Array
        arr = in_band.ReadAsArray()

        # The lower limit of the highest class = spatial resolution (the minimum distance possible without being in non-forest)
        LL = int(in_ds.GetGeoTransform()[1])

        self.progress_updated.emit(10)
        # The upper limit of the lowest class = the Negligible Risk Threshold
        UL = NRT = int(NRT)
        n_classes = int(n_classes)

        # Calculate common ratio(r)=(LLmax/LLmin)^1/n_classes
        r = np.power(LL / UL, 1/n_classes)

        # Create 2D class_array for the areas within the NRT
        class_array = np.array([[i, i + 1] for i in range(n_classes)])

        # Calculate UL and LL value for the areas within the NRT
        x= np.power(r, class_array)
        risk_class=np.multiply(UL,x)

        self.progress_updated.emit(20)
        # Create mask: areas beyond the NRT, assign class 1
        mask_arr = np.ma.masked_where(arr >= NRT , arr)
        mask_arr = mask_arr.filled(1)

        self.progress_updated.emit(30)
        # Reclassification mask_arr value >= LL into risk_class
        # (e.g., if n_class is 29, class the areas within the NRT into class 2 to 30)
        index=0
        for UL, LL in risk_class:
            mask_arr[np.where((UL > mask_arr) & (mask_arr >= LL))] = index+2
            index+=1
            # Emit progress signals of 50 and 70
            if index == int(n_classes/2):
                self.progress_updated.emit(50)
            elif index == int(n_classes):
                self.progress_updated.emit(70)

        self.progress_updated.emit(80)
        return mask_arr

    def array2raster(self, in_fn, out_fn, data, data_type, nodata=None):
        '''
        Create 30-class Vulerability Map
        :param in_fn: map of distance from the forest eddge
        :param out_fn: path to the file to create
        :param data: NumPy array containing data to write
        :param data_type: output data type
        :param nodata: optional NoData value
        :return: out_ds
        '''
        in_ds = gdal.Open(in_fn)
        output_format = in_fn.split('.')[-1].upper()
        if (output_format == 'TIF'):
            output_format = 'GTIFF'
        elif (output_format == 'RST'):
            output_format = 'rst'
        driver = gdal.GetDriverByName(output_format)
        out_ds = driver.Create(out_fn, in_ds.RasterXSize, in_ds.RasterYSize, 1, data_type, options=["BigTIFF=YES"])
        out_ds.SetProjection(in_ds.GetProjection())
        out_ds.SetGeoTransform(in_ds.GetGeoTransform())
        out_band = out_ds.GetRasterBand(1)
        if nodata is not None:
            out_band.SetNoDataValue(nodata)
        out_band.WriteArray(data)
        out_band.FlushCache()
        # Compute actual statistics include mean, minimum, maximum, and standard deviation.
        out_band.ComputeStatistics(False)
        self.progress_updated.emit(100)
        return out_ds

